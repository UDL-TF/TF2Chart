replicaCount: 1

workload:
  kind: Deployment # Deployment or StatefulSet
  nameOverride: ""
  deploymentStrategy:
    type: Recreate

statefulSet:
  nameOverride: ""
  serviceName: ""
  podManagementPolicy: OrderedReady
  updateStrategy: {}
  volumeClaimTemplates: []

app:
  name: tf2-merger
  image:
    repository: ghcr.io/udl-tf/tf2-image
    tag: latest
    pullPolicy: Always
  containerPort: 28015
  ports:
    - name: game-udp
      containerPort: 28015
      protocol: UDP
  env: []
  command: []
  args: []
  stdin: false
  tty: false
  livenessProbe: {}
  readinessProbe: {}
  startupProbe: {}
  resources: {}
  securityContext: {}
  extraVolumeMounts: []
  lifecycle: {}

# Merger stitcher init container and watcher sidecar
# IMPORTANT: Both merger and watcher MUST run as root (runAsUser: 0)
# to properly chown files to the target UID/GID (default 1000:1000).
# Do not override securityContext to run as non-root or permissions will fail.
merger:
  enabled: true
  image:
    repository: ghcr.io/udl-tf/tf2chart-merger
    tag: latest
    pullPolicy: Always
  resources: {}
  securityContext:
    runAsUser: 0
    runAsGroup: 0
    runAsNonRoot: false
  extraEnv: []
  extraVolumeMounts: []
  # Runtime decompression: paths to scan for .bz2 files during merge operations.
  # When the watcher detects new files, it will decompress any .bz2 files found in these paths.
  # IMPORTANT: Overlays referenced in these paths will automatically be mounted as writable
  # for both the stitcher init container and watcher sidecar to allow decompression.
  # Example: ["/mnt/overlays/maps", "/mnt/overlays/custom"]
  decompressPaths: []  # e.g., ["/mnt/overlays/maps", "/mnt/overlays/custom"]
  watcher:
    enabled: true
    image:
      repository: ghcr.io/udl-tf/tf2chart-watcher
      tag: latest
      pullPolicy: Always
    events:
      - close_write
      - create
      - delete
      - moved_to
      - moved_from
      - delete_self
      - move_self
    debounceSeconds: 2
    pollIntervalSeconds: 10
    watchPaths: []
    watchParentDepth: 1  # Watch parent directories for git-sync atomic swaps
    extraWatchPaths: []  # Additional paths to monitor beyond auto-detected overlays
    command: []
    args: []
    env: []
    resources: {}
    securityContext:
      runAsUser: 0
      runAsGroup: 0
      runAsNonRoot: false
    extraVolumeMounts: []
    watchBase: true

initContainers:
  pre: []
  post: []

# Decompressor init container
# Scans base and overlay paths for .bz2 files, decompresses them, and removes the archives.
# This runs before the stitcher to ensure map files are decompressed before merging.
# IMPORTANT: Overlays listed in scanOverlays will automatically be mounted as writable
# for the decompressor init container to allow decompression.
decompressor:
  enabled: true
  image:
    repository: ghcr.io/udl-tf/tf2chart-decompressor
    tag: latest
    pullPolicy: Always
  scanBase: true  # Scan the base path for .bz2 files
  scanOverlays: []  # List of overlay names to scan (e.g., ["maps", "custom"])
  resources: {}
  securityContext:
    runAsUser: 0
    runAsGroup: 0
    runAsNonRoot: false
  extraVolumeMounts: []

# Permissions init container
# IMPORTANT: This container MUST run as root (runAsUser: 0) to properly
# chown files. The securityContext is automatically set in the template.
# Do not disable runFirst/runLast if you have permission issues.
permissionsInit:
  enabled: true
  image: ghcr.io/udl-tf/tf2chart-permissions:latest
  imagePullPolicy: Always
  name: init-permissions
  user: 1000
  group: 1000
  chmod: "775"
  path: "" # Path to fix in runFirst phase (defaults to /mnt/base if empty)
  volumeName: host-base
  mountPath: /mnt/base
  runFirst: true
  runLast: true
  postName: init-permissions-final
  postPath: /tf
  postMountPath: /tf
  postVolume: view-layer
  applyDuringMerge: true
  applyPaths: [] # Paths to fix during merge (defaults to postPath if empty)

entrypointCopy:
  enabled: true
  name: init-entrypoint
  sourcePath: /tf/entrypoint.sh
  destinationPath: /tf/entrypoint.sh
  chmod: "755"
  image:
    repository: ghcr.io/udl-tf/tf2-image
    tag: latest
    pullPolicy: Always
  resources: {}
  securityContext: {}

paths:
  hostSource: /tf/standalone
  hostPathType: Directory
  containerTarget: /tf

# The additive overlay layers that are merged in order.
overlays:
  - name: serverfiles
    type: hostPath
    path: /mnt/serverfiles
    # subPath: base
    # sourcePath: serverfiles/base
    hostPathType: Directory
    readOnly: true

# Writable passthrough directories that map directly to the base host path.
writablePaths:
  - tf/logs
  # - path: tf/tf/cfg
  #   template:
  #     overlay: serverfiles-base
  #     sourcePath: tf/tf/cfg
  #     clean: true
  # - path: tf/tf/addons/sourcemod/configs/sourcebans
  #   overlay: serverfiles-runtime
  #   subPath: tf/tf/addons/sourcemod/configs/sourcebans
  # - path: tf/uploads
  #   overlay: serverfiles-runtime
  #   subPath: tf/uploads
  #   sourceMount: /mnt/overlays/serverfiles-runtime

# Copy-only templates refresh a writable directory from an overlay snapshot on
# every merge run. This is helpful for configs that should start from a clean
# template and accept runtime edits without touching the original overlay.
# Set onlyOnInit: true to copy only during initial merge and skip watcher re-merges,
# allowing the TF2 server to modify files without them being overwritten.
copyTemplates: []
  # - targetPath: tf/addons/sourcemod/configs/sourcebans
  #   overlay: serverfiles-base
  #   sourcePath: serverfiles/base/addons/sourcemod/configs/sourcebans
  #   cleanTarget: true
  #   targetMode: writable
  #   onlyOnInit: true  # Skip copying during watcher re-merges
  #   sourceMount: /mnt/overlays/serverfiles-base

hostNetwork: false
dnsPolicy: ""
serviceAccountName: ""

service:
  enabled: true
  type: ClusterIP
  port: 28015
  targetPort: 28015
  ports:
    - name: game-udp
      port: 28015
      targetPort: game-udp
      protocol: UDP
  nameOverride: ""
  headless: false
  clusterIP: ""
  externalTrafficPolicy: ""
  annotations: {}

podAnnotations: {}
podLabels: {}
podSecurityContext: {}
nodeSelector: {}
tolerations: []
affinity: {}
priorityClassName: ""
extraVolumes: []
